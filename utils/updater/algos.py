from dotmap import DotMap
from models import Algorithm

algos: DotMap = DotMap()

# ? Пузырьковая сортировка
code_bubble = (
    """def bubble(raw_data: list[int]):
    data = raw_data.copy()

    for i in range(len(data) - 1):
        if data[i] > data[i+1]:
            data[i], data[i+1] = data[i+1], data[i]

return data
""")
description_bubble = (
    "Метод пузырька (сортировка пузырьком, Bubble sort) является, пожалуй, наибо"
    "лее распространенным алгоритмом сортировки данных обменами в массиве. Назв"
    "ание этого метода пошло от аналогии с поднимающимся пузырьком. На своем пу"
    "ти он проходит все слои, каждый элемент, что и применяется в этом алгоритм"
    "е. Сам метод предполагает проход массива снизу вверх и сравнение ближайших"
    " элементов. Если какие-то из проверенных элементов массива находятся не в "
    "правильной последовательности, то меняем их местами и продолжаем сравниват"
    "ь дальше.\n\n"

    "Так как на прохождение всего массива требуется очень много времени, то мож"
    "но заключить, что алгоритм пузырька очень медленен и малоэффективен. Тем н"
    "е менее, он все же имеет плюс: его можно легко улучшать за счет его просто"
    "ты."
)
algos.bubble = Algorithm('Пузырьковая', 'Обменами',
                         'O(n²)', 3, code_bubble, description_bubble)

# ? Чётно-нечётная сортировка
code_odd_even = (
    """def odd_even(raw_data: list[int]):
    data = raw_data.copy()

    n = len(data)
    isSorted = 0
    while isSorted == 0:
        isSorted = 1
        temp = 0

        for i in range(1, n - 1, 2):
            if data[i] > data[i + 1]:
                data[i], data[i + 1] = data[i + 1], data[i]
                isSorted = 0

        for i in range(0, n - 1, 2):
            if data[i] > data[i + 1]:
                data[i], data[i + 1] = data[i + 1], data[i]
                isSorted = 0

    return data
""")
description_odd_even = (
    "В основе алгоритма — итерации по попарному сравнению соседних элементов пр"
    "и движении слева-направо. Cначала сравниваются пары, у которых первый элем"
    "ент – нечётный по счёту, а второй – чётный(т.е. первый и второй, третий и "
    "четвёртый, пятый и шестой и т.д.). Далее наоборот – чётный + нечётный(втор"
    "ой и третий, четвёртый и пятый, шестой и седьмой и т.д.). В этом случае мн"
    "огие крупные элементы массива на одной итерации одновременно делают один ш"
    "аг вперёд(в пузырьке самый крупный за итерацию доходит до конца, но осталь"
    "ные немаленькие практически все остаются на месте)."
)
algos.odd_even = Algorithm('Чёт-нечет', 'Обменами',
                           'O(n²)', 13, code_odd_even, description_odd_even)

# ? Сортировка выбором
code_selection = (
    """def selection(raw_data: list[int]):
    data = raw_data.copy()

    for i, e in enumerate(data):
        mn = min(range(i, len(data)), key=data.__getitem__)
        data[i], data[mn] = data[mn], e

    return data
""")
description_selection = (
    "Идея сортировки этого алгоритма состоит в том, что отсортированная последо"
    "вательность формируется путем добавления к ней элементов в правильном поря"
    "дке. Алгоритм основан на выборе наименьшего элемента из неотсортированной "
    "части и его переноса в конец отсортированной. Сначала программа проходит п"
    "о массиву, выбирая наименьший элемент. Как только такой найден, он перенос"
    "ится на первое место в массиве, а элемент, стоящий там, съезжает на свобод"
    "ное место. С этого момента первый элемент, он же наименьший, будет началом"
    " отсортированной части массива. Вторым шагом ищется наименьший элемент сре"
    "ди неотсортированной части и, найдя его, программа ставит его в конец отсо"
    "ртированной части. И так продолжается циклически, пока весь массив не окаж"
    "ется отсортированным.\n\n"

    "Для нахождения наименьшего элемента из массива рассматриваемых алгоритм со"
    "вершает n сравнений, тогда как число обменов всегда будет меньше числа сра"
    "внений. То есть время, затраченное на сортировку, растет квадратично, отно"
    "сительно количества элементов.\n\n"

    "Алгоритм сортировки выбором не использует дополнительной памяти, то есть в"
    "се операции происходят «на месте», без дополнительных массивов. Этот метод"
    " нельзя назвать устойчивым, так как при сортировке последовательности, сос"
    "тоящей из 3 элементов, которые имеют по 2 поля, например: 1-a, 2-a, 2-b ал"
    "горитм отсортирует последовательность в порядке: 1-a, 2-b, 2-a, что в данн"
    "ой ситуации является неверным."
)
algos.selection = Algorithm(
    'Выбором', 'Выбором', 'O(n²)', 3, code_selection, description_selection)

# ? Бинго-сортировка
code_bingo = (
    """def bingo(raw_data: list[int]):
    data = raw_data.copy()

    # Первый проход.
    max = len(data) - 1
    nextValue = data[max]
    for i in range(max - 1, -1, -1):
        if data[i] > nextValue:
            nextValue = data[i]

    while max and data[max] == nextValue:
        max -= 1

    # Последующие проходы.
    while max:
        value = nextValue
        nextValue = data[max]

        for i in range(max - 1, -1, -1):
            if data[i] == value:
                data[i], data[max] = data[max], data[i]
                max -= 1
            elif data[i] > nextValue:
                nextValue = data[i]

        while max and data[max] == nextValue:
            max -= 1

    return data
""")
description_bingo = (
    "Интересной особенностью сортировки выбором является независимость скорости"
    "от характера сортируемых данных. Например, если массив почти отсортирован,"
    " то, как известно, сортировка вставками его обработает гораздо быстрее (да"
    "же быстрее чем быстрая сортировка). А реверсивно упорядоченный массив для "
    "сортировки вставками является вырожденным случаем, она будет его сортирова"
    "ть максимально долго.\n\n"

    "Для сортировки же выбором частичная или реверсная упорядоченность массива "
    "роли не играет — она обработает его примерно с той же скоростью что и обыч"
    "ный рандом. Также для классической сортировки выбором неважно, состоит ли "
    "массив из уникальных или повторяющихся элементов — на скорость это практич"
    "ески не влияет. Тем не менее, можно модифицировать алгоритм так, чтобы при"
    " некоторых наборах данных работало быстрее. Например, бинго-сортировка учи"
    "тывает, если массив состоит из повторяющихся элементов."
)
algos.bingo = Algorithm('Бинго', 'Выбором', 'O(n²)',
                        18, code_bingo, description_bingo)

# ? Сортировка простыми вставками
code_insertion = (
    """def insertion(raw_data: list[int]):
    data = raw_data.copy()

    for i in range(len(data)):
        j = i - 1
        key = data[i]
        while data[j] > key and j >= 0:
            data[j + 1] = data[j]
            j -= 1
        data[j + 1] = key

    return data
""")
description_insertion = (
    "Основополагающим отличием сортировки вставками от других является то, что "
    "массив, с которым работает алгоритм, предварительно отсортирован наполовин"
    "у. Главная идея — сравнение первого элемента из неотсортированной части с "
    "последним элементом отсортированной. Если он больше, то он входит в отсорт"
    "ированную последовательность последним элементом. Если же он оказывается м"
    "еньше, то мы сравниваем этот элемент с предпоследним элементом отсортирова"
    "нной последовательности. И так продолжается в цикле, пока весь массив не б"
    "удет отсортирован.\n\n"

    "При близком расположении близких по величине данных место вставки обычно н"
    "аходится близко к краю отсортированной части, что позволяет вставлять с на"
    "именьшими накладными расходами. Сортировкой простыми вставками не задейств"
    "уется дополнительная память. Алгоритм является очень устойчивым. На пример"
    "е простых вставок показательно смотрится главное преимущество большинства "
    "сортировок вставками, а именно – очень быстрая обработка почти упорядоченн"
    "ых массивов(скорее всего, быстрее даже «быстрой сортировки»)."
)
algos.insertion = Algorithm(
    'Простыми вставками', 'Вставками', 'O(n²)', 18, code_insertion, description_insertion)

# ? Метод Шелла
code_shell = (
    """def shell(raw_data: list[int]):
    data = raw_data.copy()

    inc = len(data) // 2
    while inc:
        for i, el in enumerate(data):
            while i >= inc and data[i - inc] > el:
                data[i] = data[i - inc]
                i -= inc
            data[i] = el
        inc = 1 if inc == 2 else int(inc * 5.0 / 11)

    return data
""")
description_shell = (
    "Метод Шелла является модификацией алгоритма сортировки простыми вставками,"
    " но в отличие от простых вставок, сортировка Шелла не пытается слева от эл"
    "емента сразу формировать строго отсортированную часть массива. Она создаёт"
    " слева от элемента почти отсортированную часть массива и делает это достат"
    "очно быстро. "

    "В данном алгоритме первые три предварительные сортировки необходимы, чтобы"
    " подвинуть элементы к своим правильным позициям. Тогда как последняя сорти"
    "ровка окончательно загоняет их на свои места. Доказано многими исследовани"
    "ями, что такая модифицированная сортировка значительно ускоряет процесс уп"
    "орядочения массива.\n\n"

    "Единственной характеристикой сортировки Шелла является приращение - рассто"
    "яние между сортируемыми элементами, в зависимости от прохода. В конце прир"
    "ащение всегда равно единице - метод завершается обычной сортировкой вставк"
    "ами, но именно последовательность приращений определяет рост эффективности"
    "."
)
algos.shell = Algorithm('Метод Шелла', 'Вставками',
                        'O(n×log²n))', 18, code_shell, description_shell)
